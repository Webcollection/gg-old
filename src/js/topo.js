;(function () {

  var featuresToTable = function(topoObj, feature) {
    var features = topojson.feature(topoObj, topoObj.objects[feature]).features;
    features = features.filter(function(f) { return f.geometry != null;});
    var ret = [];

    features.map(function(f) {
      var polygons = null;
      if (f.geometry.type == "Polygon") {
        polygons = [f.geometry.coordinates]
      } else {
        polygons = f.geometry.coordinates
      }

      polygons = polygons.map(function(coordlist) {
        return coordlist[0].map(function(pt) {
          return {lon: pt[0], lat: pt[1]};
        });
      });

      polygons = polygons.map(function(p, idx) {
        return {
          id: f.id,
          idx: idx,
          pts: p
        }
      });

      ret = ret.concat(polygons);
    });

    return ret;

  };

  var specs = {
    layers: [
      {
        geom: "line",
        aes: {
          x: "lon",
          y: "lat",
          group: {id2: 'id', idx2: 'idx'}
        }
      }
    ]
  };

  var renderStates = function(topodata) {
    var rows = featuresToTable(topodata, "states");
    var table = gg.RowTable.fromArray(rows);
    table = table.flatten();
    console.log(table.raw());

    var w    = w || 800;
    var h    = h || 400;
    var ex   = function () {
      $("#examples").empty();
      return d3.select('#examples').append('span');
    }();
    var plot = gg(specs)
    plot.render(w, h, ex, table.raw())

  }



  // This file contains the code to define the graphics and then
  // renders them using data randomly generated by data.js.

  $(document).ready(function() {
    Math.seedrandom("zero");

    d3.json("/data/us-10m.json", function(error, topodata) {
      renderStates(topodata);
    });

  });
})();
